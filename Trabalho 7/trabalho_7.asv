%% EXTENDEND KALMAN FILTER

%% Informações de Entrada
% Medição atual dos sensores: y(k)
% Sinal de controle prévio: u(k?1)
% Estimativa prévia dos estados: x_chapeu(k?1,k?1)
% Covariâncias das estimativas prévias: P(k?1,k?1)
% Modelo não-linear atual do sistema: fk(x(k?1), u(k?1)), h(k,x(k))
% Covariâncias atuais do sistema: Q(k),R(k)

global A B C D Q R
persistent x_chapeu P

if t == 0 
    x_chapeu = [y(1) 0];
    %P = [* 0;0 **] -> *Covariância da Posição do Ângulo -> Conhecido e Definido = R 
    %P = [* 0;0 **] -> **Convariância da Velocidade do Ângulo ->
    %Desconhecido em sistemas reais, aqui sabemos que vai começar parado
    P = [R 0; 0 1e-8];
else
    %% Etapa de Predição
    %1: x_chapeuk|k?1 = fk(xk?1|k?1, uk?1)
    %2: Pk|k?1 = Ak(xk?1|k?1, uk?1) Pk?1|k?1 Ak(xk?1|k?1, uk?1)T + Qk
    
    x_chapeu(k,k-1) = fk(x(k-1,k-1), u(k-1));
    P(k,k-1) = Ak(x(k-1,k-1), u(k-1)) * P(k-1,k-1) * Ak(x(k-1,k-1), u(k-1))^T + Q(k);

    %% Etapa de Correção
    % 1: Sk = Ck(x_chapeu(k|k?1)) * P(k|k?1) * Ck(x_chapeu(k|k?1))^T + R(k)
    % 2: Lk = P(k|k?1) * Ck(x_chapeu(k|k?1))^T * S(k)^?1
    % 3: y_chapeu(k|k?1) = hk(x_chapeu k|k?1)
    % 4: x_chapeu(k|k) = x_chapeu(k|k?1) + Lk(yk ? y_chapeu(k|k?1))
    % 5: P(k|k) = P(k|k?1) ? L(k) * C(k) * (x_chapeu(k|k?1)) * P(k|k?1)

    Sk = Ck(x_chapeu(k,k-1)) * P(k,k-1) * Ck(x_chapeu(k,k-1))^T + R(k);
    Lk = P(k,k-1) * Ck(x_chapeu(k,k-1))^T * S(k)^-1;
    y_chapeu(k,k-1) = hk(x_chapeu (k,k-1));
    x_chapeu(k,k) = x_chapeu(k|k-1) + Lk(yk - y_chapeu(k,k-1));
    P(k,k) = P(k,k-1) - L(k) * C(k) * (x_chapeu(k,k-1)) * P(k,k-1);

    %% Informações de Saída
    % Estimativa atualizada dos estados: x_chapeu(k,k)
    % Covariâncias das estimativas atualizadas: P(k,k)

    %% Tarefas
    y(k) = [z(k); tetha(k)] + v(k); %zk e ?k representam respectivamente a posição real do carrinho e o ângulo real da haste em cada amostra k de controle
    R = [10^-4 0; 0 10^-4];
    x_dot = fc(x,u);
    x(k) = T * fc(x(k-1),u(k-1)) + x(k-1);
    alpha = 0.5;%? é um escalar positivo pequeno, preferencialmente menor que 1
    I = eye(4);%I é uma matriz identidade 4 por 4.
    Q = alpha * I;
end

x_chapeu = [];
P = [];



